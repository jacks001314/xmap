
#include <stdint.h>
#include <gmp.h>

#include "xm_wblist.h"
#include "xm_shard.h"

static inline uint32_t shard_roll_to_valid(xm_shard_t *s)
{
	if (s->current - 1 < s->max_index) {
		return s->current;
	}

	return xm_shard_get_next_ip(s);
}

xm_shard_t* xm_shard_create(xm_pool_t *mp, uint16_t shard_idx, uint16_t num_shards,
		uint8_t thread_idx, uint8_t num_threads,
		uint32_t max_total_targets, uint64_t max_index,xm_cycle_t *cycle,xm_wblist_t *wblist)
{


    xm_shard_t *shard = xm_palloc(mp,sizeof(*shard));
    shard->wblist = wblist;

    uint32_t num_subshards = (uint32_t)num_shards * (uint32_t)num_threads;
	uint64_t num_elts = cycle->order;

	// This instance of XMap will run T subshards, with one subshard per
	// thread. This composes a single shard, as specified by the command
	//  E.g. to run shard with index n, we must run
	// subshards with indicies the range [n*T, (n+1)*T].
	//
	// We can calculate our subshard index i = n*T + t.
	uint32_t sub_idx = shard_idx * num_threads + thread_idx;

	// Given i, we want to calculate the start of subshard i. Subshards
	// define ranges over exponents of g. They range from [0, Q-1), where Q
	// is the number of elements in (the order of) the group generated by
	// g.
	//
	// Let e_b = floor(Q / S) * i
	uint64_t exponent_begin = (num_elts / num_subshards) * sub_idx;

	// The stopping exponent is the first element of the next shard.
	//
	//     e_e = floor(Q / S) * ((i + 1) % S)
	uint64_t exponent_end =
	    (num_elts / num_subshards) * ((sub_idx + 1) % num_subshards);

	// We actually offset the begin and end of each cycle. Given an offset
	// k, shift each exponent by k modulo Q.
	exponent_begin = (exponent_begin + cycle->offset) % num_elts;
	exponent_end = (exponent_end + cycle->offset) % num_elts;

	// Multiprecision variants of everything above
	mpz_t generator_m, exponent_begin_m, exponent_end_m, prime_m;
	mpz_init_set_ui(generator_m, cycle->generator);
	mpz_init_set_ui(exponent_begin_m, exponent_begin);
	mpz_init_set_ui(exponent_end_m, exponent_end);
	mpz_init_set_ui(prime_m, cycle->group->prime);

	// Calculate the first and last points of the shard as powers of g
	// modulo p.
	mpz_t start_m, stop_m;
	mpz_init(start_m);
	mpz_init(stop_m);
	mpz_powm(start_m, generator_m, exponent_begin_m, prime_m);
	mpz_powm(stop_m, generator_m, exponent_end_m, prime_m);

	// Pull the result out as a uint64_t
	shard->params.first = (uint64_t)mpz_get_ui(start_m);
	shard->params.last = (uint64_t)mpz_get_ui(stop_m);
	shard->params.factor = cycle->generator;
	shard->params.modulus = cycle->group->prime;

	// Set the shard at the beginning.
	shard->current = shard->params.first;

    shard->max_index = max_index;

	// Set max_targets if applicable
	if (max_total_targets > 0) {
		uint32_t max_targets_this_shard =
		    max_total_targets / num_subshards;
		if (sub_idx < (max_total_targets % num_subshards)) {
			++max_targets_this_shard;
		}
		shard->state.max_targets = max_targets_this_shard;
	}

	// If the beginning of a shard isn't pointing to a valid index in the
	// blacklist, find the first element that is.
	shard_roll_to_valid(shard);

	// Clear everything
	mpz_clear(generator_m);
	mpz_clear(exponent_begin_m);
	mpz_clear(exponent_end_m);
	mpz_clear(prime_m);
	mpz_clear(start_m);
	mpz_clear(stop_m);

    return shard;
}


uint32_t xm_shard_get_cur_ip(xm_shard_t *shard)
{
	return (uint32_t)xm_wblist_lookup_index(shard->wblist,shard->current - 1);
}

static inline uint32_t shard_get_next_elem(xm_shard_t *shard)
{
	do {
		shard->current *= shard->params.factor;
		shard->current %= shard->params.modulus;
	} while (shard->current >= (1LL << 32));
	return (uint32_t)shard->current;
}

uint32_t xm_shard_get_next_ip(xm_shard_t *shard)
{
	if (shard->current == XM_SHARD_DONE) {
		return XM_SHARD_DONE;
	}
	while (1) {
		uint32_t candidate = shard_get_next_elem(shard);
		if (candidate == shard->params.last) {
			shard->current = XM_SHARD_DONE;
			return XM_SHARD_DONE;
		}
		if (candidate - 1 < shard->max_index) {
			shard->state.whitelisted++;
			return xm_wblist_lookup_index(shard->wblist,candidate - 1);
		}

		shard->state.blacklisted++;
	}
}
